---
title: "Connessioni pericolose: analisi delle interazioni della Mafia Siciliana"
author: "Susanna Micoli - 142970"
date: "10 febbraio 2025"
output: ioslides_presentation
---
<style>
  slides > slide { overflow: scroll; }
  slides > slide:not(.nobackground):after {
  content: '';
        }
</style>
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

## La Mafia Siciliana

Operazione Montagna (2007): indagine su due clan mafiosi, la "famiglia Mistretta" e il "clan Batanesi", infiltrati in attività economiche (grandi opere infrastrutturali). \

Obiettivo: Analizzare le interazioni mafiose attraverso la Network Analysis in R\

Caratteristiche della rete mafiosa:

- Durata intergenerazionale
- Legami stretti tra affiliati
- Attività illegali per perseguire obiettivi specifici

<div style="text-align:center">
  <img src="img_mafia.png" alt="Generated with DALL-E"/>
  <p>Generated with DALL-E</p>
</div>

```{r, echo = FALSE, include=FALSE}
#Carico le librerie

library(tidyverse)
library(tidygraph)
library(ggraph)
library(igraph)
library(dplyr)
library(tidyr)
library(ggcorrplot)
library(corrplot)
library(RColorBrewer)
library(ggwordcloud)
library(ggplot2)

```

```{r echo=FALSE, include=FALSE}
# Lettura dei file

nodes = as.data.frame(read.csv("data/Montagna_Roles.csv"))
edges_Meet = as.data.frame(read.csv("data/Meetings.csv"))
edges_Phone = as.data.frame(read.csv("data/Phone_Calls.csv"))

nodes
edges_Meet
edges_Phone
```

```{r echo=FALSE, include=FALSE}
# Creo la colonna 'MacroRole' per creare una macrocategoria dei ruoli
# Creo la colonna 'Clan' per riportare il nome della famiglia

nodes <- nodes %>%
  mutate(MacroRole = case_when(
    # Leadership
    grepl("boss|executive|co-founder", Role, ignore.case = TRUE) ~ "Leadership",
    
    # Affiliati
    grepl("member|intermediator", Role, ignore.case = TRUE) ~ "Affiliates and Members",
    
    # Entrepreneurs & Professionals
    Role != "" & !is.na(Role) ~ "Entrepreneurs & Professionals",
    
    # Stringhe vuote o NA
    TRUE ~ "Undefined"
  ),
  Clan = str_extract(Role, "''(.*?)''") %>%
      str_replace_all("''", "") %>%
      replace_na("")
  )
```

```{r echo=FALSE, include=FALSE}
# ------ DATASET MEETINGS -------
# Separo le colonne
edges_Meet <- edges_Meet %>%
  separate(Source.Target.Weight, into = c("to", "from", "weight"), sep = " ")

# Trasformo la colonna weight in integer
edges_Meet$weight <- as.integer(edges_Meet$weight)

# Filtro gli archi che contengono solo nodi presenti nel dataframe nodes
edges_Meet <- edges_Meet %>%
  filter(from %in% nodes$Node & to %in% nodes$Node)

# Nodi con almeno una connessione 
connected_nodes <- unique(c(edges_Meet$to, edges_Meet$from))

# Filtro i nodi che sono connessi
nodes_m <- nodes %>%
  filter(Node %in% connected_nodes)

# Creo il grafo
g_meet = graph_from_data_frame(edges_Meet, directed = FALSE, vertices = nodes_m)

```

```{r echo=FALSE, include=FALSE}
# ------ DATASET MEETINGS - componente gigante -------

# Prendo in considerazione solo la componente gigante

# Prendo un elenco delle componenti connesse nel grafo
components <- components(g_meet)

# Trovo la componente gigante e ottengo i nomi dei nodi che fanno parte della componente gigante
giant_comp_id <- which.max(components$csize)
giant_nodes <- names(components$membership[components$membership == giant_comp_id])

# Filtro i nodi e archi per mantenere solo la componente gigante
g_giant <- induced_subgraph(g_meet, vids = giant_nodes)

```

```{r echo=FALSE, include=FALSE}
# ------- DATASET PHONE CALLS -------

# Rinomino le colonne
edges_Phone <- edges_Phone %>%
  rename(
    to = Source,
    from = Target,
    weight = Weight
  )

# Filtro gli archi che contengono solo nodi presenti nel dataframe nodes
edges_Phone <- edges_Phone %>%
  filter(from %in% nodes$Node & to %in% nodes$Node)

# Considerare solo i nodi connessi da almeno un arco
connected_nodes2 <- unique(c(edges_Phone$to, edges_Phone$from))

# Nodi con almeno una connessione 
nodes_p <- nodes %>%
  filter(Node %in% connected_nodes2)

# Creo il grafo
g_phone = graph_from_data_frame(edges_Phone, directed = FALSE, vertices = nodes_p)

```

```{r echo=FALSE, include=FALSE}
# ------ DATASET PHONE CALLS - componente gigante -------

# Prendo in considerazione solo la componente gigante

# Prendo un elenco delle componenti connesse nel grafo
components <- components(g_phone)

# Trovo la componente gigante e ottengo i nomi dei nodi che fanno parte della componente gigante
giant_comp_id2 <- which.max(components$csize)
giant_nodes2 <- names(components$membership[components$membership == giant_comp_id2])

# Filtro i nodi e archi per mantenere solo la componente gigante
g_giant_p <- induced_subgraph(g_phone, vids = giant_nodes2)

```

```{r echo=FALSE, include=FALSE}
# Numero di nodi ed archi dei due grafi

n_m<-vcount(g_meet)
n_p<-vcount(g_phone)

a_m<-ecount(g_meet)
a_p<-ecount(g_phone)
```

```{r echo=FALSE, include=FALSE}
# Ci sono archi in comune tra i due grafi?

# Salvo i nomi
nodi_meet <- V(g_meet)$name  
nodi_phone <- V(g_phone)$name 

# Trovo l'intersezione tra i nodi dei due grafi
nodi_comuni <- intersect(nodi_meet, nodi_phone)

# Numero di nodi in comune
num_nodi_comuni <- length(nodi_comuni)
```

## Il dataset: reti di incontri e comunicazioni telefoniche

Dati disponibili su [Zenodo](https://zenodo.org/records/3938818#.YW4WLhxxWUl). \

Dataset contenente 3 CSV: 

- **Roles**: Ruoli degli indagati e relazioni con altri sospettati
- **Meetings**: Incontri fisici tra i sospettati (documentati tramite appostamenti della polizia)
- **Phone Calls**: Telefonate intercettate tra i sospettati

Tipologia di reti: 

- Indirette e pesate (frequenza delle interazioni come peso)
- Nodi anonimi

Le reti risultanti per gli incontri fisici e le telefonate sono queste:

```{r echo=FALSE}
# Palette di colori
palette_colors <- brewer.pal(n = length(unique(nodes$Clan)), "Set1")

# Definisco le forme per i Macroruoli
shape_mapping <- c(
    "Leadership" = 21,  
    "Affiliates and Members" = 24,  
    "Entrepreneurs & Professionals" = 22, 
    "Undefined" = 20
)

# Visualizzazione rete MEETING
ggraph(g_meet, layout = "stress") + 
  geom_edge_link(color = "grey52", alpha = 0.5) +  
  geom_node_point(aes(fill = Clan, shape = MacroRole), 
                  size = 5, color = "black", stroke = 1) +  
  scale_fill_manual(values = palette_colors, name = "Clan") +
  scale_shape_manual(values = shape_mapping, name = "MacroRole") +
  labs(title = "Network Meetings", subtitle = "Interazioni basate sugli incontri") +
  theme_void() +
  theme(legend.position = "right") +
  guides(fill = guide_legend(override.aes = list(shape = 21, size = 4)))  # Forza il colore nella legenda

```
\ 
La rete degli incontri con `r n_m` nodi e `r a_m` archi.\

- Una componente connessa gigante e piccole componenti isolate, probabilmente a causa di dati mancanti
- La famiglia Batanesi (verde) è numerosa e compatta, mentre la famiglia Mistretta è più dispersa e meno influente
- Significativa la presenza di imprenditori e professionisti che agiscono come intermediari tra il mondo legale e illegale, supportando l’organizzazione

```{r echo=FALSE}
# Filtro solo i nodi appartenenti a "Entrepreneurs & Professionals"
nodes_ep <- nodes %>%
  filter(MacroRole == "Entrepreneurs & Professionals")

# Conto le occorrenze dei diversi ruoli all'interno di questa categoria
role_counts <- nodes_ep %>%
  count(Role, sort = TRUE)

# Creo la wordcloud
ggplot(role_counts, aes(label = Role, size = n)) +
  geom_text_wordcloud() +
  scale_size_area(max_size = 15) +  
  theme_minimal() +
  labs(title = "Tag Cloud dei Ruoli - Entrepreneurs & Professionals")
```


```{r echo=FALSE}
# Visualizzazione rete PHONE CALLS
ggraph(g_phone, layout = "stress") +
  geom_edge_link(color = "grey52", alpha = 0.5) +  
  geom_node_point(aes(fill = Clan, shape = MacroRole), 
                  size = 5, color = "black", stroke = 1) +  
  scale_fill_manual(values = palette_colors, name = "Clan") +
  scale_shape_manual(values = shape_mapping, name = "MacroRole") +
  labs(title = "Network Phone Calls", subtitle = "Interazioni basate sulle chiamate") +
  theme_void() +
  theme(legend.position = "right") +
  guides(fill = guide_legend(override.aes = list(shape = 21, size = 4)))
```
\ 
La rete delle telefonate con `r n_p` nodi e `r a_p` archi. \

- Meno densa rispetto agli incontri, coinvolge meno famiglie
- Anche qui, la famiglia Batanesi (blu) ha interazioni più concentrate rispetto alla famiglia Mistretta

## Chi sono gli individui che hanno avuto più incontri o telefonate nella rete?

```{r echo=FALSE, include=FALSE}
# Converto in tibble graph
ig_meet <- as_tbl_graph(g_meet)
ig_phone <- as_tbl_graph(g_phone)

```


```{r echo=FALSE, include=FALSE}
# Calcolo le misure di centralità per la rete degli incontri e delle telefonate
# Poichè betweenness e closeness tengono conto del peso come distanza utilizzo il trucco di 
# trasformare il peso da un valore di forza della connessione a un valore di distanza tra i nodi calcolando 1/weight
# Se due persone si incontrano molto spesso (peso alto), il valore 1/weight diventa piccolo, quindi viene interpretato 
# come distanza breve
# Se due persone si incontrano raramente (peso basso), il valore 1/weight diventa grande, quindi viene interpretato
# come distanza lunga 

ig_meet <- ig_meet %>%
  activate(nodes) %>%
  mutate(
    weighted_degree = centrality_degree(weights = weight),
    betweenness = centrality_betweenness(),
    closeness = centrality_closeness(),
    weighted_eigenvector = centrality_eigen(weights = weight)
  )

ig_phone <- ig_phone %>%
  activate(nodes) %>%
  mutate(
    weighted_degree = centrality_degree(weights = weight),
    betweenness = centrality_betweenness(),
    closeness = centrality_closeness(),
    weighted_eigenvector = centrality_eigen(weights = weight)
  )
```

```{r echo=FALSE}
# Prendo i primi 10 nodi con valore più altro di degree centrality
top_wnode_meet <- ig_meet %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(weighted_degree)) %>%  
  select(name, Role, MacroRole, weighted_degree)
top_10_nodes <- top_wnode_meet$name[1:10]

# Crea il grafico
ggraph(ig_meet, layout = "stress") +
  geom_edge_link(aes(color = weight), width = 0.3, show.legend = FALSE) +
  geom_node_point(aes(size = weighted_degree, color = MacroRole)) +
  scale_edge_color_gradient(low = "lightgray", high = "black") +
  geom_node_text(aes(label = ifelse(name %in% top_10_nodes, name, "")), 
                 repel = TRUE, size = 3) +  # Etichetta solo i top 10 nodi
  theme_void() +
  ggtitle("Network Meetings - Weighted Degree Centrality") +
  theme(legend.position = "bottom", legend.box = "horizontal") +
  guides(size = "none") + 
  scale_color_manual(values = c("Leadership" = "blue", 
                                "Affiliates and Members" = "red", 
                                "Entrepreneurs & Professionals" = "green", 
                                "Undefined" = "gold4"),
                     breaks = c("Leadership", "Affiliates and Members", "Entrepreneurs & Professionals", "Undefined"))
```

```{r echo=FALSE}
head(top_wnode_meet, 10)
```
- Il Deputy Boss della famiglia Batanesi è il nodo più centrale
- La famiglia Batanesi ha più membri con ruoli influenti e più connessioni
- La famiglia Mistretta sembra meno connessa e meno influente nella rete
- Il farmacista affiliato (N22) potrebbe avere un ruolo chiave come intermediario

```{r echo=FALSE}
top_wnode_phone <- ig_phone %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(weighted_degree)) %>%  
  select(name, Role, MacroRole, weighted_degree)

top_10_nodes_p <- top_wnode_phone$name[1:10]

# Crea il grafico
ggraph(ig_phone, layout = "stress") +
  geom_edge_link(aes(color = weight), width = 0.3, show.legend = FALSE) +
  geom_node_point(aes(size = weighted_degree, color = MacroRole)) +
  scale_edge_color_gradient(low = "lightgray", high = "black") +
  geom_node_text(aes(label = ifelse(name %in% top_10_nodes_p, name, "")), 
                 repel = TRUE, size = 3) +  # Etichetta solo i top 10 nodi
  theme_void() +
  ggtitle("Network Phone Calls - Weighted Degree Centrality") +
  theme(legend.position = "bottom", legend.box = "horizontal") +
  guides(size = "none") + 
  scale_color_manual(values = c("Leadership" = "blue", 
                                "Affiliates and Members" = "red", 
                                "Entrepreneurs & Professionals" = "green", 
                                "Undefined" = "gold4"),
                     breaks = c("Leadership", "Affiliates and Members", "Entrepreneurs & Professionals", "Undefined"))
```
```{r echo=FALSE}
head(top_wnode_phone, 10)
```
- La famiglia Mistretta ha la leadership più connessa, superando il Deputy Boss dei Batanesi
- Imprenditori e intermediari emergono con ruoli chiave, come N29 e N43
- Il potere appare più distribuito tra diverse figure, anziché concentrato in una sola famiglia

Sembra quindi che la famiglia Mistretta prediliga le telefonate, mentre la famiglia Batanesi preferisca incontri segreti di persona.

## Esistono pochi nodi altamente connessi o il peso è distribuito in modo omogeneo?

```{r echo=FALSE}
# Barplot per Meetings
ggplot(edges_Meet, aes(x = weight)) + 
  geom_bar(fill = "skyblue", color = "black") + 
  theme_minimal() +
  labs(title = "Distribution of Weights in the Meetings Network",
       x = "Weight",
       y = "Frequency") +
  theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 12))
```

```{r echo=FALSE}
# Barplot per Phone Calls
ggplot(edges_Phone, aes(x = weight)) + 
  geom_bar(fill = "lightgreen", color = "black") + 
  theme_minimal() +
  labs(title = "Distribution of Weights in the Phone Calls Network",
       x = "Weight",
       y = "Frequency") +
  theme(axis.text = element_text(size = 10), 
        axis.title = element_text(size = 12))
```

- La rete segue una distribuzione esponenziale: pochi nodi con archi molto pesanti e molti nodi con poche connessioni
- Le reti scale-free sono resistenti alla rimozione casuale di nodi, ma vulnerabili alla perdita degli hub
- Nella rete degli incontri, ci sono più nodi con pochi collegamenti rispetto alla rete delle telefonate (quasi il doppio)
- Il peso massimo della rete degli incontri è 10, suggerendo che i mafiosi preferiscono incontri fisici per ridurre il rischio di intercettazioni (più semplice criptare le conversazioni e usare il linguaggio del corpo)
- I nodi con grado più alto hanno ruolo di leadership, questo collega il fatto che spesso i capo-clan partecipano a eventi per confermare il loro potere e trasmettere messaggi ai subordinati

## Chi ha il ruolo di "collegamento" nella rete?

```{r echo=FALSE}
top_betweenness <- ig_meet %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(betweenness)) %>%
  slice(1:10)  

# Creazione del barplot
ggplot(top_betweenness, aes(x = reorder(name, betweenness), 
                                     y = betweenness, fill = MacroRole)) +
  geom_bar(stat = "identity", color = "black") +  
  coord_flip() +  
  labs(title = "Top 10 - Weighted Betweenness Centrality (Meetings)", 
       x = "Nodo", y = "Weighted Betweenness") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2") 
```

```{r echo=FALSE}
top_betweenness <- top_betweenness %>%
  select(name, Role, MacroRole, betweenness)
top_betweenness

```
Non è stato utilizzato il peso degli archi nel calcolo della betweenness centrality, poiché sarebbe stato interpretato come una distanza anziché come una frequenza dei collegamenti, modificando così l'interpretazione dei dati.\

- I nodi di leadership (N18, N68, N47) sono i più centrali nella rete, con valori elevati di betweenness
- Il nodo N18, che rappresenta un esponente di alto livello della famiglia Mistretta, ha il valore di betweenness più alto (1183.04). Seguito dai leader delle famiglie Batanesi
- In secondo piano i membri e gli imprenditori (N22, N29) giocano un ruolo importante nel connettere diversi livelli della rete (collegamento e specifiche aree della rete economica o professionale)


```{r echo=FALSE}
top_betp <- ig_phone %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(betweenness)) %>%
  slice(1:10)  

# Creazione del barplot
ggplot(top_betp, aes(x = reorder(name, betweenness), 
                                     y = betweenness, fill = MacroRole)) +
  geom_bar(stat = "identity", color = "black") +  
  coord_flip() +  
  labs(title = "Top 10 - Betweenness Centrality (Phone Calls)", 
       x = "Node", y = "Betweenness") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2") 
```


```{r echo=FALSE}
top_betp <- top_betp %>%
  select(name, Role, MacroRole, betweenness)
top_betp

```
- I leader mafiosi restano i nodi più centrali nella rete delle telefonate
- N18 (fam. Mistretta) ha la betweenness più alta, seguito da N61 e N47 (vice-capo Batanesi)
- N29 (entrepreneur) mostra un'alta centralità, suggerendo un ruolo chiave nel collegamento tra la sfera criminale e il mondo economico.
- N22 (pharmacist-member) e N75 (Mistretta) agiscono come intermediari nella rete

Rispetto alla rete delle telefonate, la rete degli incontri presenta valori di betweenness più alti per i membri con ruoli di leadership, in particolare per i vertici delle famiglie mafiose.\

Tuttavia, nella rete delle telefonate, emergono figure meno visibili ma strategiche, come N29 (entrepreneur) e N22 (pharmacist-member), con valori di betweenness più alti rispetto alla rete degli incontri.\
Questo potrebbe indicare che le telefonate vengono utilizzate per facilitare la comunicazione tra affiliati con ruoli più diversificati e per gestire aspetti operativi ed economici della rete mafiosa.

## Chi può diffondere le informazioni più rapidamente all'interno della rete?

```{r echo=FALSE}
# Trasformo in tibble graph
g_giant <- as_tbl_graph(g_giant)

# Calcolo delle misure di centralità
g_giant <- g_giant %>%
  activate(nodes) %>%
  mutate(
    weighted_degree = centrality_degree(weights = weight),
    betweenness = centrality_betweenness(),
    closeness = centrality_closeness(),
    weighted_eigenvector = centrality_eigen(weights = weight)
  )
```

```{r echo=FALSE}
c_m <- g_giant %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(closeness)) %>%  
  select(name, Role, MacroRole, closeness)

c_w <- c_m$name[1:10]

# Creo il grafico
ggraph(g_giant, layout = "stress") +
  geom_edge_link(aes(color = weight), width = 0.3, show.legend = FALSE) +
  geom_node_point(aes(size = closeness, color = MacroRole)) +
  scale_edge_color_gradient(low = "lightgray", high = "black") +
  geom_node_text(aes(label = ifelse(name %in% c_w, name, "")), 
                 repel = TRUE, size = 3) +  
  theme_void() +
  ggtitle("Network Meetings - Closeness Centrality") +
  theme(legend.position = "bottom", legend.box = "horizontal") +
  guides(size = "none") + 
  scale_color_manual(values = c("Leadership" = "blue", 
                                "Affiliates and Members" = "red", 
                                "Entrepreneurs & Professionals" = "green", 
                                "Undefined" = "gold4"),
                     breaks = c("Leadership", "Affiliates and Members", "Entrepreneurs & Professionals", "Undefined"))

```

```{r echo=FALSE}
head(c_m, n=10)
```
È stata considerata solo la componente gigante perché la closeness centrality si basa sulle distanze tra i nodi e ha senso calcolarla solo tra nodi che possono effettivamente raggiungersi. Le componenti più piccole avrebbero potuto falsare l'interpretazione. \
Inoltre anche per questa misura si è preferito non considerare il peso sugli archi perché sarebbe stato interpretato nella misura come distanza e non come frequenza.

- I leader delle famiglie Mistretta e Batanesi hanno la maggiore closeness centrality, facilitando la comunicazione nella rete
- Gli imprenditori (N29 e N64) collegano la rete criminale con il mondo economico
- N43 e alcuni affiliati fungono da snodi essenziali nella comunicazione interna
- Si nota come il Boss di Cosa Nostra a Messina (N11) abbia un ruolo rilevante nell’accesso alle informazioni. Questo suggerisce che la rete non sia limitata a una singola area geografica, ma abbia connessioni più ampie.

Il boss di Cosa Nostra a Messina (N11) non ha valori elevati di degree o betweenness centrality: non mantiene molte connessioni dirette né funge da ponte. Tuttavia, il suo alto valore di closeness centrality indica una posizione strategica per raggiungere rapidamente l'intera rete.\

Questo potrebbe riflettere un modello tipico delle organizzazioni mafiose, dove i boss tendono a mantenere un profilo basso per ridurre il rischio di essere intercettati, delegando la gestione operativa a intermediari fidati. Il loro potere non deriva dalla quantità di connessioni dirette, ma dalla capacità di accedere rapidamente alle informazioni e influenzare la rete senza essere un punto di snodo evidente.


```{r echo=FALSE}
# Trasformo in tibble graph
g_giant_p <- as_tbl_graph(g_giant_p)

# Calcolo le misure di centralità
g_giant_p <- g_giant_p %>%
  activate(nodes) %>%
  mutate(
    weighted_degree = centrality_degree(weights = weight),
    betweenness = centrality_betweenness(),
    closeness = centrality_closeness(),
    weighted_eigenvector = centrality_eigen(weights = weight)
  )
```

```{r echo=FALSE}
c_p <- g_giant_p %>%
  activate(nodes) %>%
  as_tibble() %>%
  arrange(desc(closeness)) %>%  
  select(name, Role, MacroRole, closeness)

clo_p <- c_p$name[1:10]

# Creo il grafico
ggraph(g_giant_p, layout = "stress") +
  geom_edge_link(aes(color = weight), width = 0.3, show.legend = FALSE) +
  geom_node_point(aes(size = closeness, color = MacroRole)) +
  scale_edge_color_gradient(low = "lightgray", high = "black") +
  geom_node_text(aes(label = ifelse(name %in% clo_p, name, "")), 
                 repel = TRUE, size = 3) +  
  theme_void() +
  ggtitle("Network Phone Calls - Closeness Centrality") +
  theme(legend.position = "bottom", legend.box = "horizontal") +
  guides(size = "none") + 
  scale_color_manual(values = c("Leadership" = "blue", 
                                "Affiliates and Members" = "red", 
                                "Entrepreneurs & Professionals" = "green", 
                                "Undefined" = "gold4"),
                     breaks = c("Leadership", "Affiliates and Members", "Entrepreneurs & Professionals", "Undefined"))

```
```{r echo=FALSE}
head(c_p, n=10)
```
- N18 e N61 (famiglia Mistretta) hanno i valori di closeness più alti, suggerendo un ruolo chiave nella diffusione delle informazioni
- N29 rappresenta una posizione strategica al terzo posto, collegando diversi membri della rete
- La presenza tra i nodi centrali di imprenditori e professionisti, evidenzia il ruolo cruciale delle figure economiche nel flusso di informazioni
- La rete delle telefonate potrebbe riflette un flusso di informazioni legato a gestione affari e coordinamento, con ruoli economici e operativi prominenti

Le telefonate servono a coordinare l'attività quotidiana e il flusso di informazioni in modo rapido ed efficiente, gli incontri sono probabilmente utilizzati per consolidare alleanze, discutere piani importanti e gestire relazioni più intime o delicate, con una maggiore partecipazione delle figure apicali della rete.\

Questi risultati indicano che la struttura mafiosa è progettata per garantire una comunicazione efficiente tra i vari livelli dell’organizzazione, con una combinazione di leader, intermediari e figure economiche in posizioni strategiche.

## I nodi con molte connessioni sono sempre i più influenti, anche considerando i nodi a cui sono collegati?

```{r echo=FALSE}
# Calcolo le misure di centralità e crea un dataframe
centrality_df <- ig_meet %>%
  activate(nodes) %>%
  as_tibble() %>%
  select(weighted_degree, betweenness, closeness, weighted_eigenvector)  

# Calcolo la matrice di correlazione utilizzando il metodo di Spearman
cor_matrix <- cor(centrality_df, method = "spearman")

# Estraggo il valore della correlazione tra weighted_degree e weighted_eigenvector
corr_m<-cor_matrix["weighted_degree", "weighted_eigenvector"]
```

```{r echo=FALSE}
df_compare <- data.frame(
  name = V(ig_meet)$name,
  weighted_degree = V(ig_meet)$weighted_degree,
  weighted_eigenvector = V(ig_meet)$weighted_eigenvector
)

# Creazione del grafico
ggplot(df_compare, aes(x = weighted_degree, y = weighted_eigenvector)) +
  geom_point(alpha = 0.6, color = "blue") +  
  geom_smooth(method = "lm", color = "red", se = FALSE) +  
  theme_minimal() +  
  labs(
    title = "Correlation between Weighted Degree and Eigenvector Centrality",
    subtitle = "Network Meetings"
  )
```

- La correlazione del valore di `r corr_m` nella rete degli incontri suggerisce che chi ha molte connessioni è anche centrale ed importante
- I nodi con un alto grado hanno anche connessioni con individui strategici
- La rete appare altamente gerarchica, con pochi nodi centrali che influenzano la diffusione delle informazioni

```{r echo=FALSE}
df_compare <- data.frame(
  name = V(ig_phone)$name,
  weighted_degree = V(ig_phone)$weighted_degree,
  weighted_eigenvector = V(ig_phone)$weighted_eigenvector
)

ggplot(df_compare, aes(x = weighted_degree, y = weighted_eigenvector)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  theme_minimal() +
  labs(
    title = "Correlation between Weighted Degree and Eigenvector Centrality",
    subtitle = "Network Phone Calls"
  )

```

```{r echo=FALSE}
# Calcolo le misure di centralità e crea un dataframe
centrality_df <- ig_phone %>%
  activate(nodes) %>%
  as_tibble() %>%
  select(weighted_degree, betweenness, closeness, weighted_eigenvector)  

# Calcolo la matrice di correlazione utilizzando il metodo di Spearman
cor_matrix <- cor(centrality_df, method = "spearman")

# Estraggo il valore della correlazione tra weighted_degree e weighted_eigenvector
corr_p<-cor_matrix["weighted_degree", "weighted_eigenvector"]
```

- La correlazione nella rete delle telefonate è di `r corr_p`
- Il legame tra weighted degree ed eigenvector centrality è meno forte rispetto alla rete degli incontri
- Le connessioni nella rete delle telefonate risultano più distribuite e meno centralizzate attorno a pochi nodi chiave, con una maggiore eterogeneità nei ruoli 

## Le reti degli incontri e delle telefonate seguono le stesse dinamiche comunicative o rispondono a esigenze diverse?

```{r echo=FALSE}
# Lunghezza media dei cammini

camm_m<-mean_distance(ig_meet)
camm_p<-mean_distance(ig_phone)
```

```{r echo=FALSE}
# Diametro della rete 
diameter_meet <- diameter(ig_meet, weights = NA)
diameter_phone <- diameter(ig_phone, weights = NA)

```

```{r echo=FALSE}
# Densità della rete
density_meet <- edge_density(ig_meet)
density_phone <- edge_density(ig_phone)
```

```{r echo = FALSE}
# Calcolo del grado medio in ig_meet usando la colonna dei gradi pesati
mean_weighted_degree_meet <- mean(V(ig_meet)$weighted_degree)

# Calcolo del grado medio in ig_phone usando la colonna dei gradi pesati
mean_weighted_degree_phone <- mean(V(ig_phone)$weighted_degree)

```



```{r echo=FALSE}
# Trovo il diametro della rete (lista di nodi)
diam_meet <- get_diameter(ig_meet, directed = FALSE)

# Assegno i colori ai nodi
V(ig_meet)$diameter_node <- ifelse(V(ig_meet)$name %in% V(ig_meet)[diam_meet]$name, "red", "lightgreen")

# Trovo gli archi che appartengono al diametro
edges_in_diameter <- c()
for (i in seq(length(diam_meet) - 1)) {
  edge_id <- get.edge.ids(ig_meet, c(diam_meet[i], diam_meet[i + 1]))
  edges_in_diameter <- c(edges_in_diameter, edge_id)
}

# Assegno i colori agli archi
E(ig_meet)$diameter_edge <- ifelse(seq_along(E(ig_meet)) %in% edges_in_diameter, "red", "darkgray")

# Converto il grafo in formato tbl_graph per ggraph
graph_tbl <- as_tbl_graph(ig_meet)

# Creo il grafico
ggraph(graph_tbl, layout = "stress") +
  geom_edge_link(aes(color = factor(diameter_edge)), width = 0.7, alpha = 0.8) +  
  geom_node_point(aes(color = factor(diameter_node)), size = 4, stroke = 1) +  
  scale_edge_color_manual(values = c("red" = "red", "darkgray" = "darkgray")) +
  scale_color_manual(values = c("red" = "red", "lightgreen" = "lightgreen")) + 
  geom_node_text(aes(label = ifelse(V(graph_tbl)$name %in% V(graph_tbl)[diam_meet]$name, V(graph_tbl)$name, "")), 
                 repel = TRUE, size = 3) + 
  theme_void() +
  ggtitle("Diameter of the Meetings Network") +
  theme(legend.position = "none")+
  guides(size = "none")
```

```{r echo=FALSE}
# Trovo il diametro della rete (lista di nodi)
diam_meet <- get_diameter(ig_phone, directed = FALSE)

# Assegno i colori ai nodi
V(ig_phone)$diameter_node <- ifelse(V(ig_phone)$name %in% V(ig_phone)[diam_meet]$name, "red", "lightblue")

# Trovo gli archi che appartengono al diametro
edges_in_diameter <- c()
for (i in seq(length(diam_meet) - 1)) {
  edge_id <- get.edge.ids(ig_phone, c(diam_meet[i], diam_meet[i + 1]))
  edges_in_diameter <- c(edges_in_diameter, edge_id)
}

# Assegno i colori agli archi
E(ig_phone)$diameter_edge <- ifelse(seq_along(E(ig_phone)) %in% edges_in_diameter, "red", "darkgray")

# Converto il grafo in formato tbl_graph per ggraph
graph_tbl <- as_tbl_graph(ig_phone)

# Creo il grafico
ggraph(graph_tbl, layout = "stress") +
  geom_edge_link(aes(color = factor(diameter_edge)), width = 0.7, alpha = 0.8) +  
  geom_node_point(aes(color = factor(diameter_node)), size = 4, stroke = 1) +  
  scale_edge_color_manual(values = c("red" = "red", "darkgray" = "darkgray")) +
  scale_color_manual(values = c("red" = "red", "lightblue" = "lightblue")) +  
  geom_node_text(aes(label = ifelse(V(graph_tbl)$name %in% V(graph_tbl)[diam_meet]$name, V(graph_tbl)$name, "")), 
                 repel = TRUE, size = 3) + 
  theme_void() +
  ggtitle("Diameter of the Phone Calls Network") +
  theme(legend.position = "none")+
  guides(size = "none")
```

- La rete degli incontri è più compatta e interconnessa rispetto a quella delle telefonate, con una densità maggiore (`r density_meet` vs. `r density_phone`) e un numero più alto di connessioni (`r a_m` vs. `r a_p`)
- Le informazioni si propagano più rapidamente attraverso gli incontri fisici, come dimostra la lunghezza media dei cammini più bassa (`r camm_m` vs. `r camm_p`) e un diametro leggermente inferiore (`r diameter_meet` vs. `r diameter_phone`)
- In media, un nodo negli incontri ha quasi il doppio delle connessioni rispetto alla rete delle telefonate (grado medio ponderato di `r mean_weighted_degree_meet` vs. `r mean_weighted_degree_phone`), suggerendo interazioni più frequenti e dirette
- Le telefonate sembrano seguire una logica più selettiva e dispersa, probabilmente per motivi di sicurezza e coordinamento operativo
- Mentre gli incontri fisici potrebbero essere utilizzati per la trasmissione di informazioni strategiche e riservate, le telefonate servirebbero a mantenere i contatti senza esporre eccessivamente la rete
- Pur avendo lo stesso numero di nodi (`r n_m`), la rete delle telefonate risulta più frammentata e meno efficiente nel collegare direttamente i membri

## Come varia la distribuzione delle lunghezze dei percorsi più brevi all'interno della rete?

```{r echo=FALSE}
# Calcolo la matrice delle distanze pesate per la rete ig_meet
dist_matrix_meet_weighted <- distances(ig_meet, weights = E(ig_meet)$weight)

# Estraggo tutte le distanze come un vettore, escludendo i valori Inf (nodi non connessi)
distances_meet <- dist_matrix_meet_weighted[dist_matrix_meet_weighted < Inf]

# Calcolo la matrice delle distanze pesate per la rete ig_phone
dist_matrix_phone_weighted <- distances(ig_phone, weights = E(ig_phone)$weight)

# Estraggo tutte le distanze come un vettore, escludendo i valori Inf
distances_phone <- dist_matrix_phone_weighted[dist_matrix_phone_weighted < Inf]

# Creo un data frame per le distribuzioni delle distanze
data_distribution <- data.frame(
  Network = c(rep("ig_meet", length(distances_meet)),
              rep("ig_phone", length(distances_phone))),
  Shortest_Path_Length = c(distances_meet, distances_phone)
)

# Creo l'istogramma per la distribuzione delle lunghezze dei cammini
ggplot(data_distribution, aes(x = Shortest_Path_Length, fill = Network)) +
  geom_histogram(bins = 30, alpha = 0.7, position = "dodge") +
  theme_minimal() +
  labs(title = "Distribution of Shortest Path Lengths (Weighted)",
       x = "Shortest Path Length",
       y = "Frequency") +
  scale_fill_manual(values = c("blue", "orange")) +
  theme(legend.position = "top")
```

- La distribuzione della rete degli incontri è concentrata su cammini più brevi, indicano una comunicazione rapida ed efficiente
- La distribuzione della rete delle teelfonate è più ampia, con cammini più lunghi, suggerendo una comunicazione dispersa e meno diretta
- L'assenza di cammini troppo corti o troppo lunghi in entrambe le reti favorisce interazioni tra affiliati in posizioni intermedie per evitare rischi (sovraesposizione o intercettazioni)
- Una minore frequenza di interazioni nelle chiamate telefoniche rispetto agli incontri fa si che il clan cerchi di ridurre il rischio di intercettazioni, proteggendo i membri di rango più alto

## Quali sono i nodi in comune? 

```{r echo=FALSE}
# Visualizzazione grafo Meetings

ig_meet2 <- ig_meet %>%
  activate(nodes) %>%
  mutate(color = ifelse(name %in% nodi_comuni, "red", "palegreen"),
         label = ifelse(name %in% nodi_comuni, as.character(name), NA))

ggraph(ig_meet2, layout = "stress") + 
  geom_edge_link(color = "palegreen4", alpha = 0.6) + 
  geom_node_point(aes(color = color), size = 3) +  # Colori assegnati dinamicamente
  geom_node_text(aes(label = label), size = 3, repel = TRUE, na.rm = TRUE) +  # Etichette solo per i nodi in comune
  scale_color_identity() +  # Usa direttamente i colori assegnati
  labs(title = "Network Meetings") +
  theme_void() +
  theme(legend.position = "none")

```


```{r echo=FALSE}
# Visualizzazione grafo Phone Calls
ig_phone2 <- ig_phone %>%
  activate(nodes) %>%
  mutate(color = ifelse(name %in% nodi_comuni, "red", "deepskyblue"),
         label = ifelse(name %in% nodi_comuni, as.character(name), NA))

ggraph(ig_phone2, layout = "stress") + 
  geom_edge_link(color = "deepskyblue4", alpha = 0.6) + 
  geom_node_point(aes(color = color), size = 3) +  # Colori assegnati dinamicamente
  geom_node_text(aes(label = label), size = 3, repel = TRUE, na.rm = TRUE) +  # Etichette solo per i nodi in comune
  scale_color_identity() +  # Usa direttamente i colori assegnati
  labs(title = "Network Phone Calls") +
  theme_void() +
  theme(legend.position = "none")

```

Si nota come la maggior parte dei nodi, in entrambe le reti siano centrali alla componente connessa gigante. 

## Quali macro-ruoli sono più frequentemente soggetti ad arresto tra i nodi in comune?

```{r echo=FALSE}

# Estraggo i dati dei nodi comuni da entrambe le reti
nodi_comuni_meet <- ig_meet %>%
  activate(nodes) %>%
  filter(name %in% nodi_comuni) %>%
  select(name, Request, Role, MacroRole, weighted_degree) %>%
  as_tibble()

nodi_comuni_phone <- ig_phone %>%
  activate(nodes) %>%
  filter(name %in% nodi_comuni) %>%
  select(name, Request, Role, MacroRole, weighted_degree) %>%
  as_tibble()

# Controllo che i valori di Request siano uguali per entrambe le reti
# Unisco i due dataset per i nodi comuni, confrontando i valori di Request
nodi_comuni_confrontati <- full_join(nodi_comuni_meet, nodi_comuni_phone, by = "name", suffix = c("_meet", "_phone"))

# Aggiungo una colonna per verificare se i valori di Request sono uguali nelle due reti
nodi_comuni_confrontati <- nodi_comuni_confrontati %>%
  mutate(request_match = ifelse(Request_meet == Request_phone, "Match", "Mismatch"))

# Metto a posto i valori della colonna Request_meet
nodi_comuni_confrontati <- nodi_comuni_confrontati %>%
  mutate(Request_meet = case_when(
    is.na(Request_meet) | Request_meet == "" ~ "undefined",  
    Request_meet == "arrest request denied" ~ "arrest request denied",  
    Request_meet == "house arrest" ~ "house arrested",  
    TRUE ~ "arrested"  
  ))

```

```{r echo=FALSE}
# Prima, raggruppo per 'Request' e 'MacroRole' e calcolo il numero di nodi in ciascun gruppo
nodi_comuni_agg <- nodi_comuni_confrontati %>%
  group_by(Request_meet, MacroRole_meet) %>%
  summarise(count = n(), .groups = "drop")

# Visualizzazione
ggplot(nodi_comuni_agg, aes(x = Request_meet, y = count, fill = MacroRole_meet)) +
  geom_bar(stat = "identity", position = "dodge") + 
  labs(x = "Request", 
       y = "Number of Common Nodes", 
       title = "Arrest Requests Divided by Macro-Roles for Common Nodes",
       fill = "MacroRole") +  
  theme_minimal() +  
  scale_fill_brewer(palette = "Set3") +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r echo=FALSE}
nodi_leadership_arrested <- nodi_comuni_meet %>%
  filter(MacroRole == "Leadership", Request == "arrested") %>%
  arrange(desc(weighted_degree))
head(nodi_leadership_arrested)

nodi_aff_arrested <- nodi_comuni_meet %>%
  filter(MacroRole == "Affiliates and Members", Request == "arrested") %>%
  arrange(desc(weighted_degree))
head(nodi_aff_arrested)
```
- La maggior parte degli arresti riguarda i ruoli di membri e affiliati e imprenditori
- Gli individui arrestati sono anche i nodi più importanti rappresentati nelle visualizzazioni precedenti 
- Anche il nodo N22 rientra tra gli individui arrestati. Questo conferma la sua vicinanza alle attività mafiose

## Quale metrica è più efficace nel disgregare la rete?
```{r echo=FALSE}
# Definisco una funzione per calcolare la dimensione delle componenti connesse dopo aver rimosso i nodi
remove_and_get_components <- function(graph, nodes_to_remove) {
  g_copy <- graph
  g_copy <- g_copy %>%
    activate(nodes) %>%
    filter(!name %in% nodes_to_remove)  # Rimuove i nodi specificati
  return(components(g_copy)$no)  # Restituisce il numero di componenti connesse
}

# Creo un vettore per il numero di nodi da rimuovere
num_nodes_removed <- seq(0, 50, by = 1)

# Creo un data frame per memorizzare i risultati

fragmentation <- data.frame(
  Nodes_Removed = num_nodes_removed,
  Random_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_meet
    nodes_to_remove <- sample(V(g_temp), size = n)
    g_temp <- delete_vertices(g_temp, nodes_to_remove)
    components(g_temp)$no
  }),
  Degree_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_meet
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(weighted_degree)) %>%
      slice_head(n = n) %>%
      pull(name)  
    remove_and_get_components(g_temp, nodes_to_remove)
  }),
  Betweenness_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_meet
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(betweenness)) %>%
      slice_head(n = n) %>%
      pull(name) 
    remove_and_get_components(g_temp, nodes_to_remove)
  }),
  Eigen_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_meet
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(weighted_eigenvector)) %>%
      slice_head(n = n) %>%
      pull(name)  
    remove_and_get_components(g_temp, nodes_to_remove)
  })
)


ggplot(fragmentation, aes(x = Nodes_Removed)) +
  geom_line(aes(y = Random_Removal, color = "Random Removal"), size = 1) +
  geom_line(aes(y = Degree_Removal, color = "Degree Removal"), size = 1) +
  geom_line(aes(y = Betweenness_Removal, color = "Betweenness Removal"), size = 1) +
  geom_line(aes(y = Eigen_Removal, color = "Eigen Removal"), size = 1) +
  labs(title = "Network Fragmentation Analysis",
       subtitle = "Meetings Network",
       x = "Number of Nodes Removed",
       y = "Number of Connected Components") +
  theme_minimal() +
  scale_color_manual(values = c("Random Removal" = "Black", "Degree Removal" = "blue", 
                                "Betweenness Removal" = "green", "Eigen Removal" = "purple"))

```

- La strategia migliore è la scelta della metrica betweenness
- Ottima anche la scelta di rimozione dei nodi in base al grado
- La rimozione casuale non ottiene buoni risultati. Questo conferma che la rete non ha una struttura casuale

```{r echo=FALSE}
fragmentation <- data.frame(
  Nodes_Removed = num_nodes_removed,
  Random_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_phone
    nodes_to_remove <- sample(V(g_temp), size = n)
    g_temp <- delete_vertices(g_temp, nodes_to_remove)
    components(g_temp)$no
  }),
  Degree_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_phone
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(weighted_degree)) %>%
      slice_head(n = n) %>%
      pull(name)  
    remove_and_get_components(g_temp, nodes_to_remove)
  }),
  Betweenness_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_phone
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(betweenness)) %>%
      slice_head(n = n) %>%
      pull(name) 
    remove_and_get_components(g_temp, nodes_to_remove)
  }),
  Eigen_Removal = sapply(num_nodes_removed, function(n) {
    g_temp <- ig_phone
    nodes_to_remove <- g_temp %>%
      activate(nodes) %>%
      arrange(desc(weighted_eigenvector)) %>%
      slice_head(n = n) %>%
      pull(name)  
    remove_and_get_components(g_temp, nodes_to_remove)
  })
)


ggplot(fragmentation, aes(x = Nodes_Removed)) +
  geom_line(aes(y = Random_Removal, color = "Random Removal"), size = 1) +
  geom_line(aes(y = Degree_Removal, color = "Degree Removal"), size = 1) +
  geom_line(aes(y = Betweenness_Removal, color = "Betweenness Removal"), size = 1) +
  geom_line(aes(y = Eigen_Removal, color = "Eigen Removal"), size = 1) +
  labs(title = "Network Fragmentation Analysis",
       subtitle = "Phone Calls Network",
       x = "Number of Nodes Removed",
       y = "Number of Connected Components") +
  theme_minimal() +
  scale_color_manual(values = c("Random Removal" = "Black", "Degree Removal" = "blue", 
                                "Betweenness Removal" = "green", "Eigen Removal" = "purple"))

```

- La frammentazione è più rapida rispetto alla rete degli incontri poichè la rete delle telefonate è meno coesa e più dipendente da un numero limitato di nodi chiave
- Si possono rimuovere fino a circa 20 nodi scegliendo qualsiasi metrica ad eccezione della rimozione casuale
- Fino a 40 nodi rimossi si ottengono gli stessi risultati utilizzando sia la metrica betweenness sia il grado. Poi La metrica betweenness sembra ottenere migliori risultati
- La rimzione casuale anche in questo caso non rappresenta una strategia efficace

## Conclusioni
- L'analisi delle reti di incontri e telefonate evidenzia una struttura gerarchica, con i nodi centrali (leader e affiliati) essenziali per la diffusione delle informazioni e la coesione della rete mafiosa.
- La rete degli incontri è più compatta e diretta, favorendo comunicazioni rapide e sicure, mentre la rete delle telefonate è più dispersa e selettiva, probabilmente per evitare intercettazioni.
- Le telefonate facilitano il coordinamento delle attività quotidiane e il rapido scambio di informazioni, mentre gli incontri servono probabilmente a rafforzare alleanze, discutere strategie cruciali e gestire relazioni riservate, coinvolgendo maggiormente le figure di vertice della rete.
- I nodi chiave, come i leader e gli imprenditori, sono centrali nella rete, mentre figure come il farmacista e gli intermediari collegano il mondo criminale a quello legale.
- La rimozione di nodi chiave causa la rapida frammentazione della rete, indicando una struttura non casuale e dipendente da pochi hub centrali per il coordinamento.
- In sintesi, entrambe le reti mostrano un equilibrio tra efficienza comunicativa e sicurezza, con i nodi chiave vulnerabili al rischio di arresto.

##

> **"La lotta alla mafia dev’essere innanzitutto un movimento culturale che abitui tutti a sentire la bellezza del fresco profumo della libertà che si oppone al puzzo del compromesso morale, dell’indifferenza, della contiguità e quindi della complicità."**  
> — *Paolo Borsellino* 

Grazie per l'attenzione.\

Susanna Micoli
